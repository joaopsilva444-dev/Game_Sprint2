<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Database Defender</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
  <script>
    let player;
    let dataPoints = [];
    let bugs = [];
    let tables = [];
    let score = 0;
    let gameOver = false;

    function setup() {
      createCanvas(800, 600);
      player = new Player(width / 2, height - 50);
      // Criar tabelas (destinos dos dados)
      tables.push(new Table(150, 100, "Users"));
      tables.push(new Table(400, 100, "Orders"));
      tables.push(new Table(650, 100, "Products"));
      // Criar dados iniciais
      for (let i = 0; i < 5; i++) {
        dataPoints.push(new DataPoint());
      }
      // Criar bugs iniciais
      for (let i = 0; i < 3; i++) {
        bugs.push(new Bug());
      }
    }

    function draw() {
      background(220);
      
      if (!gameOver) {
        // Atualizar e desenhar jogador
        player.update();
        player.show();
        
        // Atualizar e desenhar pontos de dados
        for (let i = dataPoints.length - 1; i >= 0; i--) {
          dataPoints[i].show();
          if (player.collidesWith(dataPoints[i])) {
            dataPoints[i].collected = true;
            player.carrying = dataPoints[i];
          }
          if (dataPoints[i].collected) {
            dataPoints[i].x = player.x;
            dataPoints[i].y = player.y - 20;
          }
        }
        
        // Verificar entrega de dados nas tabelas
        if (player.carrying) {
          for (let table of tables) {
            if (player.collidesWith(table) && player.carrying.type === table.type) {
              score += 10;
              dataPoints = dataPoints.filter(dp => dp !== player.carrying);
              player.carrying = null;
              dataPoints.push(new DataPoint()); // Adicionar novo dado
            }
          }
        }
        
        // Atualizar e desenhar bugs
        for (let bug of bugs) {
          bug.update();
          bug.show();
          if (player.collidesWith(bug)) {
            gameOver = true;
          }
        }
        
        // Desenhar tabelas
        for (let table of tables) {
          table.show();
        }
        
        // Mostrar pontuação
        textSize(20);
        fill(0);
        text(`Score: ${score}`, 10, 30);
      } else {
        // Tela de Game Over
        textSize(32);
        fill(255, 0, 0);
        textAlign(CENTER);
        text("Game Over!", width / 2, height / 2);
        text(`Score Final: ${score}`, width / 2, height / 2 + 40);
        text("Pressione R para Reiniciar", width / 2, height / 2 + 80);
      }
    }

    function keyPressed() {
      if (keyCode === 82 && gameOver) { // Tecla R para reiniciar
        score = 0;
        gameOver = false;
        dataPoints = [];
        bugs = [];
        player = new Player(width / 2, height - 50);
        for (let i = 0; i < 5; i++) {
          dataPoints.push(new DataPoint());
        }
        for (let i = 0; i < 3; i++) {
          bugs.push(new Bug());
        }
      }
    }

    class Player {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 30;
        this.speed = 5;
        this.carrying = null;
      }
      
      update() {
        if (keyIsDown(LEFT_ARROW)) this.x -= this.speed;
        if (keyIsDown(RIGHT_ARROW)) this.x += this.speed;
        if (keyIsDown(UP_ARROW)) this.y -= this.speed;
        if (keyIsDown(DOWN_ARROW)) this.y += this.speed;
        
        // Limitar movimento dentro da tela
        this.x = constrain(this.x, 0, width - this.size);
        this.y = constrain(this.y, 0, height - this.size);
      }
      
      show() {
        fill(0, 0, 255);
        rect(this.x, this.y, this.size, this.size);
      }
      
      collidesWith(obj) {
        return (this.x < obj.x + obj.size &&
                this.x + this.size > obj.x &&
                this.y < obj.y + obj.size &&
                this.y + this.size > obj.y);
      }
    }

    class DataPoint {
      constructor() {
        this.size = 20;
        this.x = random(this.size, width - this.size);
        this.y = random(200, height - this.size);
        this.types = ["Users", "Orders", "Products"];
        this.type = random(this.types);
        this.collected = false;
      }
      
      show() {
        if (!this.collected) {
          fill(0, 255, 0);
          ellipse(this.x + this.size / 2, this.y + this.size / 2, this.size);
          fill(0);
          textSize(12);
          textAlign(CENTER);
          text(this.type.charAt(0), this.x + this.size / 2, this.y + this.size / 2 + 4);
        }
      }
    }

    class Bug {
      constructor() {
        this.size = 25;
        this.x = random(this.size, width - this.size);
        this.y = random(200, height - this.size);
        this.speedX = random(-2, 2);
        this.speedY = random(-2, 2);
      }
      
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        
        // Colisão com as bordas
        if (this.x <= 0 || this.x >= width - this.size) this.speedX *= -1;
        if (this.y <= 200 || this.y >= height - this.size) this.speedY *= -1;
      }
      
      show() {
        fill(255, 0, 0);
        triangle(
          this.x, this.y,
          this.x + this.size, this.y,
          this.x + this.size / 2, this.y + this.size
        );
      }
    }

    class Table {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.size = 50;
        this.type = type;
      }
      
      show() {
        fill(100, 100, 255);
        rect(this.x, this.y, this.size, this.size);
        fill(0);
        textSize(14);
        textAlign(CENTER);
        text(this.type, this.x + this.size / 2, this.y + this.size / 2 + 4);
      }
    }
  </script>
</body>
</html>